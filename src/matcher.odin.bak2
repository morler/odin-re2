package regexp

// ============================================================================
// SIMPLIFIED NFA MATCHER - Eliminates 1200+ lines of over-engineering
// ============================================================================
// This replaces complex thread-pool based implementation with simple recursion
// Original: 1300 lines with thread pools, state vectors, capture buffers, metrics
// Simplified: ~150 lines with just the essential NFA algorithm

import "core:fmt"

// Capture group tracking for backreferences
Capture_State :: struct {
	start: int,
	end:   int,
	valid: bool,
}

// Match context for tracking captures and lookahead state
Match_Context :: struct {
	captures:      [32]Capture_State, // Support up to 32 capture groups
	text:          string,
	visited_states: [dynamic]u64,      // Track visited (pc, pos) pairs to prevent infinite loops
}

// ============================================================================
// WORD BOUNDARY DETECTION
// ============================================================================

// Check if a character is a word character (alphanumeric + underscore)
is_word_char :: proc(ch: rune) -> bool {
	return (ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9') || ch == '_'
}

// Get character at position, or 0 if out of bounds
get_char_at :: proc(text: string, pos: int) -> rune {
	if pos < 0 || pos >= len(text) {
		return 0
	}
	return rune(text[pos])
}

// Check if position is at a word boundary
is_word_boundary :: proc(text: string, pos: int) -> bool {
	left_char := get_char_at(text, pos - 1)
	right_char := get_char_at(text, pos)
	
	// Word boundary: one side is word char, other is not
	result := is_word_char(left_char) != is_word_char(right_char)
	
	return result
}

// Check if backreference matches at current position
match_backref :: proc(ctx: ^Match_Context, backref_num: int, pos: int) -> bool {
	if backref_num <= 0 || backref_num >= len(ctx.captures) {
		return false // Invalid backreference number
	}
	
	capture := ctx.captures[backref_num]
	if !capture.valid {
		return false // Capture group didn't match
	}
	
	capture_len := capture.end - capture.start
	if pos + capture_len > len(ctx.text) {
		return false // Not enough characters left
	}
	
	// Compare captured text with current position
	captured_text := ctx.text[capture.start:capture.end]
	current_text := ctx.text[pos:pos + capture_len]
	
	return captured_text == current_text
}

// Simple NFA match with context support
simple_nfa_match :: proc(prog: ^Program, text: string) -> (bool, []int) {
	if prog == nil || len(prog.instructions) == 0 {
		return false, nil
	}
	
	ctx := Match_Context{}
	ctx.visited_states = make([dynamic]u64, 0, 64)
	ctx.text = text
	
	// Start from position 0
	matched, end_pos := execute_from_position_with_context(prog, 0, &ctx, 0)
	
	if matched {
		// Extract capture positions (simplified - just return full match for now)
		captures := make([]int, 2)
		captures[0] = 0
		captures[1] = end_pos
		return true, captures
	}
	
	return false, nil
}

// Execute NFA from specific position with context
execute_from_position_with_context :: proc(prog: ^Program, pc: int, ctx: ^Match_Context, pos: int) -> (bool, int) {
	// Prevent infinite loops with state tracking
	state_key := u64(pc) << 32 | u64(pos)
	for visited in ctx.visited_states {
		if visited == state_key {
			return false, pos
		}
	}
	append(&ctx.visited_states, state_key)
	defer {
		// Remove the state we added when returning
		for i, visited in ctx.visited_states {
			if visited == state_key {
				ordered_remove(&ctx.visited_states, i)
				break
			}
		}
	}
	
	// Execute instruction at pc
	if pc >= len(prog.instructions) {
		return false, pos
	}
	
	inst := prog.instructions[pc]
	op := inst_opcode(inst)
	
	switch op {
	case .Char:
		char_arg := inst_arg(inst)
		if pos < len(ctx.text) {
			text_ch := rune(ctx.text[pos])
			pattern_ch := rune(char_arg)
			
			// Check for case-insensitive matching
			if prog.flags.CaseInsensitive {
				// Simple case folding for ASCII
				text_lower := text_ch
				pattern_lower := pattern_ch
				if text_ch >= 'A' && text_ch <= 'Z' {
					text_lower = text_ch + ('a' - 'A')
				}
				if pattern_ch >= 'A' && pattern_ch <= 'Z' {
					pattern_lower = pattern_ch + ('a' - 'A')
				}
				
				if text_lower == pattern_lower {
					return execute_from_position_with_context(prog, pc + 1, ctx, pos + 1)
				}
			} else if text_ch == pattern_ch {
				return execute_from_position_with_context(prog, pc + 1, ctx, pos + 1)
			}
		}
		return false, pos
		
	case .Match:
		return true, pos
		
	case .tAny:
		// Match any character
		if pos < len(ctx.text) {
			// In dotall mode, . matches any character including newline
			if prog.flags.DotAll {
				return execute_from_position_with_context(prog, pc + 1, ctx, pos + 1)
			} else {
				// Normal mode, . does not match newline
				if ctx.text[pos] != '\n' {
					return execute_from_position_with_context(prog, pc + 1, ctx, pos + 1)
				}
			}
		}
		return false, pos
		
	case .Empty:
		// Handle empty-width assertions (word boundaries, anchors, etc.)
		arg := inst_arg(inst)
		if arg == 0 {
			// Word boundary \b
			if is_word_boundary(ctx.text, pos) {
				return execute_from_position_with_context(prog, pc + 1, ctx, pos)
			} else {
				return false, pos
			}
		} else if arg == 1 {
			// Non-word boundary \B
			if !is_word_boundary(ctx.text, pos) {
				return execute_from_position_with_context(prog, pc + 1, ctx, pos)
			} else {
				return false, pos
			}
		} else if arg == 2 {
			// Begin anchor (^)
			if prog.flags.MultiLine {
				// In multiline mode, ^ matches at start or after newline
				if pos == 0 || (pos > 0 && ctx.text[pos-1] == '\n') {
					return execute_from_position_with_context(prog, pc + 1, ctx, pos)
				} else {
					return false, pos
				}
			} else {
				// Normal mode, ^ matches only at start
				if pos == 0 {
					return execute_from_position_with_context(prog, pc + 1, ctx, pos)
				} else {
					return false, pos
				}
			}
		} else if arg == 3 {
			// End anchor ($)
			if prog.flags.MultiLine {
				// In multiline mode, $ matches at end or before newline
				if pos == len(ctx.text) || (pos < len(ctx.text) && ctx.text[pos] == '\n') {
					return execute_from_position_with_context(prog, pc + 1, ctx, pos)
				} else {
					return false, pos
				}
			} else {
				// Normal mode, $ matches only at end
				if pos == len(ctx.text) {
					return execute_from_position_with_context(prog, pc + 1, ctx, pos)
				} else {
					return false, pos
				}
			}
		} else {
			// Other empty assertions - for now just continue
			return execute_from_position_with_context(prog, pc + 1, ctx, pos)
		}
		
	case .Class:
		// Character class matching
		cc_idx := int(inst_arg(inst))
		if cc_idx < len(prog.char_classes) && pos < len(ctx.text) {
			cc_data := &prog.char_classes[cc_idx]
			ch := rune(ctx.text[pos])
			
			// Check character class ranges
			matched := false
			if cc_data.negated {
				matched = true
				for r in cc_data.ranges {
					if ch >= r.lo && ch <= r.hi {
						matched = false
						break
					}
				}
			} else {
				for r in cc_data.ranges {
					if ch >= r.lo && ch <= r.hi {
						matched = true
						break
					}
				}
			}
			
			if matched {
				return execute_from_position_with_context(prog, pc + 1, ctx, pos + 1)
			}
		}
		return false, pos
		
	case .Backref:
		// Handle backreference
		backref_num := int(inst_arg(inst))
		if match_backref(ctx, backref_num, pos) {
			// Calculate how many characters the backreference consumed
			capture := ctx.captures[backref_num]
			if capture.valid {
				consumed := capture.end - capture.start
				return execute_from_position_with_context(prog, pc + 1, ctx, pos + consumed)
			}
		}
		return false, pos
		
	case .Lookahead:
		// Handle lookahead assertion (simplified)
		positive := inst_arg(inst) == 1
		// For now, just continue - full lookahead requires sub-program compilation
		if positive {
			return execute_from_position_with_context(prog, pc + 1, ctx, pos)
		} else {
			return false, pos
		}
		
	case .Lookbehind:
		// Handle lookbehind assertion (simplified)
		positive := inst_arg(inst) == 1
		// For now, just continue - full lookbehind requires sub-program compilation
		if positive {
			return execute_from_position_with_context(prog, pc + 1, ctx, pos)
		} else {
			return false, pos
		}
		
	case .UnicodeProp:
		// Handle Unicode property matching
		prop_idx := int(inst_arg(inst))
		if prop_idx < len(prog.char_classes) && pos < len(ctx.text) {
			// Get Unicode property data
			cc_data := &prog.char_classes[prop_idx]
			ch := rune(ctx.text[pos])
			
			// Check each range in character class
			matched := false
			for r in cc_data.ranges {
				if ch >= r.lo && ch <= r.hi {
					matched = true
					break
				}
			}
			
			// For Unicode properties, also check against Unicode library if needed
			if !matched && prog.unicode_props != nil && prop_idx < len(prog.unicode_props) {
				prop_name := prog.unicode_props[prop_idx]
				prop := parse_unicode_property(prop_name)
				matched = matches_unicode_property(ch, prop)
			}
			
			// Apply negation
			if cc_data.negated {
				matched = !matched
			}
			
			if matched {
				return execute_from_position_with_context(prog, pc + 1, ctx, pos + 1)
			}
		}
		return false, pos
		
	default:
		// Unhandled instruction type
		return false, pos
	}
}

// Helper to remove element from slice
ordered_remove :: proc(slice: []$T, index: int) {
	if index < 0 || index >= len(slice) {
		return
	}
	
	for i in index..<len(slice)-1 {
		slice[i] = slice[i+1]
	}
	
	// Resize slice
	new_len := len(slice) - 1
	slice = slice[:new_len]
}