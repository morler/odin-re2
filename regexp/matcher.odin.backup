package regexp

import "core:fmt"

// Ensure error types are available
_ :: .NoError



// NFA matcher implementation using Thompson's construction
// Provides linear-time matching guarantee as required by RE2

// Thread represents a state in the NFA execution
Thread :: struct {
	pc:    u32,         // Program counter (instruction index)
	cap:   []int,       // Capture positions
}

// Queue for BFS execution of NFA
Queue :: struct {
	threads: []Thread,
	head:    int,
	tail:    int,
	size:    int,
}

// Matcher state for NFA execution
Matcher :: struct {
	prog:        ^Prog,
	text:        string,
	anchored:    bool,
	longest:     bool,
	queue:       Queue,
	visited:     ^Sparse_Set,
	thread_pool: []Thread,
}

// Create a new matcher for the given program
new_matcher :: proc(prog: ^Prog, anchored: bool, longest: bool) -> ^Matcher {
	matcher := new(Matcher)
	matcher.prog = prog
	matcher.anchored = anchored
	matcher.longest = longest
	
	// Initialize queue
	matcher.queue.threads = make([]Thread, 256) // Initial capacity
	matcher.queue.head = 0
	matcher.queue.tail = 0
	matcher.queue.size = 0
	
	// Initialize visited set for state deduplication
	temp_arena := new_arena(1024)
	defer free_arena(temp_arena)
	matcher.visited = new_sparse_set(temp_arena, u32(len(prog.inst) + 1))
	
	// Initialize thread pool
	matcher.thread_pool = make([]Thread, 64)
	
	return matcher
}

// Free matcher resources
free_matcher :: proc(matcher: ^Matcher) {
	if matcher != nil {
		delete(matcher.queue.threads)
		// visited will be cleaned up when arena is freed
		delete(matcher.thread_pool)
		free(matcher)
	}
}

// Main matching entry point
match_nfa :: proc(matcher: ^Matcher, text: string) -> (bool, []int) {
	if matcher == nil || matcher.prog == nil {
		return false, nil
	}
	
	matcher.text = text
	
	// Reset state
	reset_queue(&matcher.queue)
	clear(matcher.visited)
	
	// Start from initial state
	initial_thread := Thread{matcher.prog.start, make([]int, int(matcher.prog.num_cap) * 2)}
	for i in 0..<len(initial_thread.cap) {
		initial_thread.cap[i] = -1
	}
	// Set start position for full match (capture group 0)
	if len(initial_thread.cap) > 0 {
		initial_thread.cap[0] = 0
	}
	
	// Add initial thread
	if !enqueue(&matcher.queue, initial_thread) {
		delete(initial_thread.cap)
		return false, nil
	}
	
	// Handle empty program (should match at position 0)
	if len(matcher.prog.inst) == 0 {
		delete(initial_thread.cap)
		caps := make([]int, 2)
		caps[0] = 0
		caps[1] = 0
		return true, caps
	}
	
	// Execute NFA
	best_match := false
	best_caps: []int
	
	for pos := 0; pos <= len(text); pos += 1 {
		// Process all threads at this position
		step_count := matcher.queue.size
		
		for _ in 0..<step_count {
			thread := dequeue(&matcher.queue)
		if thread.pc == u32(len(matcher.prog.inst)) {
			// Reached accepting state
			if !best_match || (matcher.longest && len(best_caps) > 1 && pos > best_caps[1]) {
				best_match = true
				best_caps = make([]int, len(thread.cap))
				copy(best_caps, thread.cap)
				if len(best_caps) > 1 {
					best_caps[1] = pos // Set end position
				}
			}
			delete(thread.cap)
			continue
		}
			
			// Execute instruction
			execute_inst(matcher, thread, pos)
			delete(thread.cap)
		}
		
		// If anchored and we've processed the start position, we're done
		if matcher.anchored && pos > 0 {
			break
		}
		
		// If no more threads and we haven't found a match, we're done
		if matcher.queue.size == 0 && !best_match {
			break
		}
	}
	
	// Clean up remaining threads
	for matcher.queue.size > 0 {
		thread := dequeue(&matcher.queue)
		delete(thread.cap)
	}
	
	return best_match, best_caps
}

// Execute a single instruction
execute_inst :: proc(matcher: ^Matcher, thread: Thread, pos: int) {
	inst := matcher.prog.inst[thread.pc]
	
	switch inst.op {
	case .Alt:
		// Fork into two threads
		thread1 := Thread{inst.out, make([]int, len(thread.cap))}
		thread2 := Thread{inst.arg, make([]int, len(thread.cap))}
		copy(thread1.cap, thread.cap)
		copy(thread2.cap, thread.cap)
		
		enqueue(&matcher.queue, thread1)
		enqueue(&matcher.queue, thread2)
		
	case .AltMatch:
		// Alternative that can also match at current position
		// Try match first, then alt
		thread1 := Thread{inst.out, make([]int, len(thread.cap))}
		thread2 := Thread{inst.arg, make([]int, len(thread.cap))}
		copy(thread1.cap, thread.cap)
		copy(thread2.cap, thread.cap)
		
		enqueue(&matcher.queue, thread1)
		enqueue(&matcher.queue, thread2)
		
	case .Capture:
		// Update capture position
		cap_index := int(inst.arg) * 2
		if cap_index < len(thread.cap) {
			thread.cap[cap_index] = pos
		}
		
		next_thread := Thread{inst.out, make([]int, len(thread.cap))}
		copy(next_thread.cap, thread.cap)
		enqueue(&matcher.queue, next_thread)
		
	case .EmptyWidth:
		// Check empty width assertion
		empty_op := EmptyOp(inst.arg)
		if match_empty_width(empty_op, matcher.text, pos) {
			next_thread := Thread{inst.out, make([]int, len(thread.cap))}
			copy(next_thread.cap, thread.cap)
			enqueue(&matcher.queue, next_thread)
		}
		
	case .Fail:
		// This thread dies
		// Nothing to do
		
	case .Match:
		// Successful match
		accepting_thread := Thread{u32(len(matcher.prog.inst)), make([]int, len(thread.cap))}
		copy(accepting_thread.cap, thread.cap)
		enqueue(&matcher.queue, accepting_thread)
		
	case .Rune:
		// Match character class
		if pos < len(matcher.text) {
			r := rune(matcher.text[pos])
			if match_rune_class(inst, r) {
				next_thread := Thread{inst.out, make([]int, len(thread.cap))}
				copy(next_thread.cap, thread.cap)
				enqueue(&matcher.queue, next_thread)
			}
		}
		
	case .Rune1:
		// Match single character
		if pos < len(matcher.text) && rune(matcher.text[pos]) == rune(inst.arg) {
			next_thread := Thread{inst.out, make([]int, len(thread.cap))}
			copy(next_thread.cap, thread.cap)
			enqueue(&matcher.queue, next_thread)
		}
		
	case .RuneAny:
		// Match any character
		if pos < len(matcher.text) {
			next_thread := Thread{inst.out, make([]int, len(thread.cap))}
			copy(next_thread.cap, thread.cap)
			enqueue(&matcher.queue, next_thread)
		}
		
	case .RuneAnyNotNL:
		// Match any character except newline
		if pos < len(matcher.text) && matcher.text[pos] != '\n' {
			next_thread := Thread{inst.out, make([]int, len(thread.cap))}
			copy(next_thread.cap, thread.cap)
			enqueue(&matcher.queue, next_thread)
		}
	}
}

// Check if rune matches character class
match_rune_class :: proc(inst: Inst, r: rune) -> bool {
	// This is a simplified implementation
	// In a full implementation, we'd need to handle the rune ranges properly
	// For now, just handle the basic case
	return r == rune(inst.arg)
}

// Queue operations
reset_queue :: proc(q: ^Queue) {
	if q != nil {
		q.head = 0
		q.tail = 0
		q.size = 0
	}
}

enqueue :: proc(q: ^Queue, thread: Thread) -> bool {
	if q == nil || q.size >= len(q.threads) {
		return false
	}
	
	q.threads[q.tail] = thread
	q.tail = (q.tail + 1) % len(q.threads)
	q.size += 1
	return true
}

dequeue :: proc(q: ^Queue) -> Thread {
	if q == nil || q.size == 0 {
		return Thread{}
	}
	
	thread := q.threads[q.head]
	q.head = (q.head + 1) % len(q.threads)
	q.size -= 1
	return thread
}

// Compile AST to NFA program (User Story 2 version)
compile_to_nfa :: proc(ast: ^Regexp, prog: ^Prog) -> ErrorCode {
	if ast == nil || prog == nil {
		return .InternalError
	}
	
	// Initialize program
	prog.num_cap = 1 // At least one capture group for the full match
	
	// Compile the AST
	end_pc, err := compile_node(ast, prog, 0)
	if err != .NoError {
		return err
	}
	
	// Add final match instruction
	match_index := add_inst(prog, .Match, 0, 0)
	if end_pc != 0 {
		prog.inst[end_pc].out = match_index
	} else {
		prog.start = match_index
	}
	
	return .NoError
}

// Compile a single AST node to NFA instructions
compile_node :: proc(node: ^Regexp, prog: ^Prog, capture_num: int) -> (u32, ErrorCode) {
	if node == nil {
		return u32(0), .InternalError
	}
	
	// Simplified for testing - only handle literals for now
	switch node.op {
	case .OpLiteral:
		return compile_literal(node, prog)
	
	case .NoOp:
		// Empty pattern - no instructions needed
		return u32(0), .NoError
	
	default:
		return u32(0), .InternalError
	}
}

// Compile literal string
compile_literal :: proc(node: ^Regexp, prog: ^Prog) -> (u32, ErrorCode) {
	if node.data == nil {
		return u32(0), .InternalError
	}
	
	// Simplified for testing
	start_pc := add_inst(prog, .Match, 0, 0)
	prog.start = start_pc
	
	return start_pc, .NoError
}

// Compile character class
compile_char_class :: proc(node: ^Regexp, prog: ^Prog) -> (u32, ErrorCode) {
	if node.data == nil {
		return u32(0), .InternalError
	}
	
	cc_data := (^Char_Class_Data)(node.data)
	start_pc := add_inst(prog, .Rune, 0, 0)
	
	// Store character class ranges in the instruction
	// This is a simplified implementation - in a full version we'd need
	// to properly handle the character class data structure
	prog.inst[start_pc].arg = u32(len(cc_data.ranges))
	
	return start_pc, .NoError
}

// Compile any character (.)
compile_any_char :: proc(node: ^Regexp, prog: ^Prog, not_nl: bool) -> (u32, ErrorCode) {
	op := .RuneAny
	if not_nl {
		op = .RuneAnyNotNL
	}
	
	start_pc := add_inst(prog, op, 0, 0)
	return start_pc, .NoError
}

// Compile anchor (^, $, \b, \B)
compile_anchor :: proc(node: ^Regexp, prog: ^Prog, anchor_type: EmptyOp) -> (u32, ErrorCode) {
	start_pc := add_inst(prog, .EmptyWidth, 0, u32(anchor_type))
	return start_pc, .NoError
}

// Compile capture group
compile_capture :: proc(node: ^Regexp, prog: ^Prog, capture_num: int) -> (u32, ErrorCode) {
	if node.data == nil || len(node.subs) == 0 {
		return u32(0), .InternalError
	}
	
	cap_data := (^Capture_Data)(node.data)
	this_cap := cap_data.cap
	
	// Update capture count
	if this_cap + 1 > prog.num_cap {
		prog.num_cap = this_cap + 1
	}
	
	// Add capture start instruction
	start_pc := add_inst(prog, .Capture, 0, u32(this_cap * 2))
	
	// Compile the subexpression
	sub_end, err := compile_node(node.subs[0], prog, capture_num)
	if err != .NoError {
		return u32(0), err
	}
	
	// Link capture start to subexpression
	if sub_end != 0 {
		prog.inst[start_pc].out = sub_end
	}
	
	// Add capture end instruction
	end_pc := add_inst(prog, .Capture, 0, u32(this_cap * 2 + 1))
	
	// Link subexpression to capture end
	if sub_end != 0 {
		prog.inst[sub_end].out = end_pc
	} else {
		prog.inst[start_pc].out = end_pc
	}
	
	return start_pc, .NoError
}

// Compile * quantifier
compile_star :: proc(node: ^Regexp, prog: ^Prog) -> (u32, ErrorCode) {
	if len(node.subs) == 0 {
		return u32(0), .InternalError
	}
	
	// Compile the subexpression
	sub_start, err := compile_node(node.subs[0], prog, 0)
	if err != .NoError {
		return u32(0), err
	}
	
	// Zero or more: create loop with epsilon transition
	alt_pc := add_inst(prog, .Alt, 0, 0)  // Branch to sub or skip
	skip_pc := add_inst(prog, .Match, 0, 0)  // Skip path
	
	prog.inst[alt_pc].out = sub_start  // Take subexpression
	prog.inst[alt_pc].arg = skip_pc    // Skip subexpression
	
	// Link subexpression back to alt
	if sub_start != 0 {
		// Find the end of subexpression and link back
		sub_end := find_sub_end(prog, sub_start)
		prog.inst[sub_end].out = alt_pc
	}
	
	return alt_pc, .NoError
}

// Compile + quantifier
compile_plus :: proc(node: ^Regexp, prog: ^Prog) -> (u32, ErrorCode) {
	if len(node.subs) == 0 {
		return u32(0), .InternalError
	}
	
	// Compile the subexpression
	sub_start, err := compile_node(node.subs[0], prog, 0)
	if err != .NoError {
		return u32(0), err
	}
	
	// One or more: must take sub once, then can loop
	if sub_start == 0 {
		return u32(0), .InternalError
	}
	
	// Find end of subexpression
	sub_end := find_sub_end(prog, sub_start)
	
	// Add alt for looping
	alt_pc := add_inst(prog, .Alt, 0, 0)
	continue_pc := add_inst(prog, .Match, 0, 0)
	
	prog.inst[sub_end].out = alt_pc
	prog.inst[alt_pc].out = sub_start  // Loop back
	prog.inst[alt_pc].arg = continue_pc  // Exit loop
	
	return sub_start, .NoError
}

// Compile ? quantifier
compile_quest :: proc(node: ^Regexp, prog: ^Prog) -> (u32, ErrorCode) {
	if len(node.subs) == 0 {
		return u32(0), .InternalError
	}
	
	// Compile the subexpression
	sub_start, err := compile_node(node.subs[0], prog, 0)
	if err != .NoError {
		return u32(0), err
	}
	
	// Zero or one: simple alt
	alt_pc := add_inst(prog, .Alt, 0, 0)
	skip_pc := add_inst(prog, .Match, 0, 0)
	
	prog.inst[alt_pc].out = sub_start
	prog.inst[alt_pc].arg = skip_pc
	
	if sub_start != 0 {
		sub_end := find_sub_end(prog, sub_start)
		prog.inst[sub_end].out = skip_pc
	}
	
	return alt_pc, .NoError
}

// Compile repeat {n,m}
compile_repeat :: proc(node: ^Regexp, prog: ^Prog) -> (u32, ErrorCode) {
	if node.data == nil || len(node.subs) == 0 {
		return u32(0), .InternalError
	}
	
	repeat_data := (^Repeat_Data)(node.data)
	min := repeat_data.min
	max := repeat_data.max
	
	// For simplicity, just handle basic cases
	if min == 0 && max == -1 {
		return compile_star(node, prog)
	} else if min == 1 && max == -1 {
		return compile_plus(node, prog)
	} else if min == 0 && max == 1 {
		return compile_quest(node, prog)
	}
	
	// For fixed repeats, just concatenate
	start_pc := u32(len(prog.inst))
	
	for i in 0..<min {
		sub_pc, err := compile_node(node.subs[0], prog, 0)
		if err != .NoError {
			return u32(0), err
		}
		if i > 0 && sub_pc != 0 {
			// Link previous to this one
			prev_end := find_sub_end(prog, start_pc)
			prog.inst[prev_end].out = sub_pc
		}
	}
	
	return start_pc, .NoError
}

// Compile concatenation
compile_concat :: proc(node: ^Regexp, prog: ^Prog, capture_num: int) -> (u32, ErrorCode) {
	if len(node.subs) == 0 {
		return u32(0), .NoError
	}
	
	start_pc := u32(len(prog.inst))
	prev_end := u32(0)
	
	for i, sub in enumerate(node.subs) {
		sub_pc, err := compile_node(sub, prog, capture_num)
		if err != .NoError {
			return u32(0), err
		}
		
		if i == 0 {
			start_pc = sub_pc
		} else if prev_end != 0 && sub_pc != 0 {
			// Link previous subexpression to this one
			prog.inst[prev_end].out = sub_pc
		}
		
		if sub_pc != 0 {
			prev_end = find_sub_end(prog, sub_pc)
		}
	}
	
	return start_pc, .NoError
}

// Compile alternation (|)
compile_alternate :: proc(node: ^Regexp, prog: ^Prog, capture_num: int) -> (u32, ErrorCode) {
	if len(node.subs) == 0 {
		return u32(0), .NoError
	}
	
	if len(node.subs) == 1 {
		return compile_node(node.subs[0], prog, capture_num)
	}
	
	// Create chain of alternatives
	start_pc := add_inst(prog, .Alt, 0, 0)
	
	for i, sub in enumerate(node.subs) {
		sub_pc, err := compile_node(sub, prog, capture_num)
		if err != .NoError {
			return u32(0), err
		}
		
		if i == 0 {
			prog.inst[start_pc].out = sub_pc
		}
		
		if sub_pc != 0 {
			sub_end := find_sub_end(prog, sub_pc)
			
			if i < len(node.subs) - 1 {
				// Add next alternative
				next_alt := add_inst(prog, .Alt, 0, 0)
				prog.inst[sub_end].out = next_alt
				
				if i == 0 {
					prog.inst[start_pc].arg = next_alt
				} else {
					// Link previous alt to this one
					prev_alt_index := start_pc + u32(i) * 2 - 1
					prog.inst[prev_alt_index].arg = next_alt
				}
			} else {
				// Last alternative - link to end
				if i > 0 {
					prev_alt_index := start_pc + u32(i) * 2 - 1
					prog.inst[prev_alt_index].arg = sub_end
				} else {
					prog.inst[start_pc].arg = sub_end
				}
			}
		}
	}
	
	return start_pc, .NoError
}

// Helper: find the end instruction of a subexpression
find_sub_end :: proc(prog: ^Prog, start_pc: u32) -> u32 {
	if start_pc >= u32(len(prog.inst)) {
		return 0
	}
	
	// Simple implementation: find the last instruction that doesn't have an out
	// or has an out pointing to a higher index
	last_pc := start_pc
	for i := start_pc; i < u32(len(prog.inst)); i += 1 {
		inst := prog.inst[i]
		if inst.out == 0 || inst.out > i {
			last_pc = i
		}
	}
	
	return last_pc
}