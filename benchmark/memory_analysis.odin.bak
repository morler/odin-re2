package main

import "core:fmt"
import "core:os"
import "core:strings"
import "../regexp"

// Memory usage analysis for Odin RE2 implementation
// This helps identify memory leaks and allocation patterns

Memory_Stats :: struct {
	allocations: int,
	total_bytes: i64,
	peak_bytes: i64,
	pattern_count: int,
	match_count: int,
}

// Global memory tracking (simplified)
global_memory: Memory_Stats

// Track memory allocation
track_allocation :: proc(bytes: int) {
	global_memory.allocations += 1
	global_memory.total_bytes += i64(bytes)
	if global_memory.total_bytes > global_memory.peak_bytes {
		global_memory.peak_bytes = global_memory.total_bytes
	}
}

// Test memory usage patterns
test_memory_patterns :: proc() {
	fmt.println("=== MEMORY USAGE ANALYSIS ===")
	
	// Reset stats
	global_memory = Memory_Stats{}
	
	// Test 1: Pattern compilation memory
	fmt.println("\n1. Pattern Compilation Memory:")
	
	patterns := []string{
		"simple",
		"[a-z]+",
		"hello|world",
		"a*b+c?",
		"^start.*end$",
		"([0-9]+)-([a-z]+)",
	}
	
	for i in 0..<len(patterns) {
		pattern_str := patterns[i]
		
		// Track before compilation
		before_allocs := global_memory.allocations
		
		pattern, err := regexp.regexp(pattern_str)
		global_memory.pattern_count += 1
		
		after_allocs := global_memory.allocations
		allocs_for_pattern := after_allocs - before_allocs
		
		fmt.printf("Pattern %q: %d allocations\n", pattern_str, allocs_for_pattern)
		
		if err == .NoError && pattern != nil {
			regexp.free_regexp(pattern)
		}
	}
	
	// Test 2: Repeated pattern reuse
	fmt.println("\n2. Pattern Reuse Memory:")
	
	pattern, err := regexp.regexp("test_pattern")
	if err == .NoError && pattern != nil {
		global_memory.pattern_count += 1
		
		before_allocs := global_memory.allocations
		
		// Use pattern multiple times
		for i in 0..<100 {
			input := fmt.tprintf("test_string_%d", i)
			result, match_err := regexp.match(pattern, input)
			global_memory.match_count += 1
			_ = result
			_ = match_err
		}
		
		after_allocs := global_memory.allocations
		allocs_for_matches := after_allocs - before_allocs
		
		fmt.printf("100 matches with reused pattern: %d allocations\n", allocs_for_matches)
		fmt.printf("Average per match: %.2f allocations\n", f64(allocs_for_matches) / 100.0)
		
		regexp.free_regexp(pattern)
	}
	
	// Test 3: Memory leak detection
	fmt.println("\n3. Memory Leak Detection:")
	
	before_total := global_memory.total_bytes
	before_allocs := global_memory.allocations
	
	// Create and destroy many patterns
	for i in 0..<50 {
		pattern_str := fmt.tprintf("pattern_%d", i)
		pattern, err := regexp.regexp(pattern_str)
		global_memory.pattern_count += 1
		
		if err == .NoError && pattern != nil {
			// Use it once
			input := fmt.tprintf("input_%d", i)
			result, match_err := regexp.match(pattern, input)
			global_memory.match_count += 1
			_ = result
			_ = match_err
			
			// Free it
			regexp.free_regexp(pattern)
		}
	}
	
	after_total := global_memory.total_bytes
	after_allocs := global_memory.allocations
	
	total_growth := after_total - before_total
	allocs_growth := after_allocs - before_allocs
	
	fmt.printf("50 create/use/free cycles:\n")
	fmt.printf("  Memory growth: %d bytes\n", total_growth)
	fmt.printf("  Allocation growth: %d\n", allocs_growth)
	
	if total_growth == 0 {
		fmt.println("  ✅ No memory leaks detected")
	} else {
		fmt.printf("  ⚠️  Potential memory leak: %d bytes\n", total_growth)
	}
	
	// Test 4: Large pattern memory
	fmt.println("\n4. Large Pattern Memory:")
	
	large_pattern_data := make([]u8, 3000)
	for i in 0..<1000 {
		large_pattern_data[i] = 'a'
	}
	for i in 1000..<2000 {
		large_pattern_data[i] = 'b'
	}
	for i in 2000..<3000 {
		large_pattern_data[i] = 'c'
	}
	large_pattern := string(large_pattern_data)
	
	pattern_before_bytes := global_memory.total_bytes
	pattern_before_allocs := global_memory.allocations
	
	large_pattern_compiled, large_err := regexp.regexp(large_pattern)
	global_memory.pattern_count += 1
	
	pattern_after_bytes := global_memory.total_bytes
	pattern_after_allocs := global_memory.allocations
	
	pattern_memory := pattern_after_bytes - pattern_before_bytes
	pattern_allocs := pattern_after_allocs - pattern_before_allocs
	
	fmt.printf("Large 3KB pattern: %d bytes, %d allocations\n", pattern_memory, pattern_allocs)
	
	if large_err == .NoError && large_pattern_compiled != nil {
		// Test matching with large input
		large_input_data := make([]u8, 20003)
		for i in 0..<10000 {
			large_input_data[i] = 'x'
		}
		large_input_data[10000] = 'a'
		large_input_data[10001] = 'b'
		large_input_data[10002] = 'c'
		for i in 10003..<20003 {
			large_input_data[i] = 'y'
		}
		large_input := string(large_input_data)
		
		match_before := global_memory.total_bytes
		result, match_err := regexp.match(large_pattern_compiled, large_input)
		global_memory.match_count += 1
		match_after := global_memory.total_bytes
		
		match_memory := match_after - match_before
		fmt.printf("Large pattern match: %d bytes\n", match_memory)
		fmt.printf("Match result: %v\n", result.matched)
		_ = match_err
		
		regexp.free_regexp(large_pattern_compiled)
	}
}

// Analyze memory efficiency
analyze_efficiency :: proc() {
	fmt.println("\n=== MEMORY EFFICIENCY ANALYSIS ===")
	
	if global_memory.pattern_count > 0 {
		avg_pattern_memory := f64(global_memory.total_bytes) / f64(global_memory.pattern_count)
		fmt.printf("Average memory per pattern: %.2f bytes\n", avg_pattern_memory)
	}
	
	if global_memory.match_count > 0 {
		avg_match_allocs := f64(global_memory.allocations) / f64(global_memory.match_count)
		fmt.printf("Average allocations per match: %.2f\n", avg_match_allocs)
	}
	
	fmt.printf("Peak memory usage: %d bytes\n", global_memory.peak_bytes)
	fmt.printf("Total allocations: %d\n", global_memory.allocations)
	
	// Efficiency recommendations
	if global_memory.peak_bytes < 1024 * 1024 { // Less than 1MB
		fmt.println("✅ Memory usage is excellent")
	} else if global_memory.peak_bytes < 10 * 1024 * 1024 { // Less than 10MB
		fmt.println("✅ Memory usage is reasonable")
	} else {
		fmt.println("⚠️  Memory usage is high - consider optimization")
	}
	
	if global_memory.allocations < global_memory.match_count * 2 {
		fmt.println("✅ Allocation efficiency is good")
	} else {
		fmt.println("⚠️  High allocation rate - consider arena allocation")
	}
}

main :: proc() {
	fmt.println("Odin RE2 Memory Analysis Tool")
	fmt.println("==============================")
	
	test_memory_patterns()
	analyze_efficiency()
	
	fmt.println("\n=== SUMMARY ===")
	fmt.printf("Patterns processed: %d\n", global_memory.pattern_count)
	fmt.printf("Matches performed: %d\n", global_memory.match_count)
	fmt.printf("Total allocations: %d\n", global_memory.allocations)
	fmt.printf("Peak memory: %d bytes\n", global_memory.peak_bytes)
	
	fmt.println("\n=== COMPARISON NOTES ===")
	fmt.println("Compare these metrics with Rust regex:")
	fmt.println("- Rust uses more sophisticated memory management")
	fmt.println("- Arena allocation in Odin should provide better control")
	fmt.println("- Look for patterns with excessive allocations")
}