package main

import "core:fmt"
import "core:time"
import "../src/regexp"

TestCase :: struct {
	name:     string,
	pattern:  string,
	text:     string,
	expected: bool,
	category: string,
}

// Run comprehensive functionality tests
run_functionality_tests :: proc() {
	fmt.println("=== Odin RE2 Functionality Tests ===")
	fmt.println()
	
	test_cases := []TestCase{
		// Basic literals
		{"simple_literal", "hello", "hello world", true, "basic"},
		{"not_found", "xyz", "hello world", false, "basic"},
		{"empty_pattern", "", "anything", true, "basic"},
		{"empty_text", "hello", "", false, "basic"},
		
		// Anchors
		{"start_anchor", "^hello", "hello world", true, "anchors"},
		{"start_anchor_fail", "^hello", "world hello", false, "anchors"},
		{"end_anchor", "world$", "hello world", true, "anchors"},
		{"end_anchor_fail", "world$", "world hello", false, "anchors"},
		{"both_anchors", "^hello world$", "hello world", true, "anchors"},
		
		// Character classes
		{"simple_class", "[abc]", "b", true, "classes"},
		{"class_range", "[a-z]", "m", true, "classes"},
		{"class_negated", "[^abc]", "d", true, "classes"},
		{"class_fail", "[abc]", "d", false, "classes"},
		
		// Quantifiers
		{"star_zero", "ab*c", "ac", true, "quantifiers"},
		{"star_many", "ab*c", "abbbbc", true, "quantifiers"},
		{"plus_one", "ab+c", "abc", true, "quantifiers"},
		{"plus_many", "ab+c", "abbbbc", true, "quantifiers"},
		{"plus_zero_fail", "ab+c", "ac", false, "quantifiers"},
		{"question_present", "ab?c", "abc", true, "quantifiers"},
		{"question_absent", "ab?c", "ac", true, "quantifiers"},
		
		// Alternation
		{"simple_alt", "cat|dog", "cat", true, "alternation"},
		{"alt_second", "cat|dog", "dog", true, "alternation"},
		{"alt_fail", "cat|dog", "bird", false, "alternation"},
		{"multiple_alt", "a|b|c|d", "c", true, "alternation"},
		
		// Groups
		{"simple_group", "(ab)+", "abab", true, "groups"},
		{"nested_group", "(a(b)c)+", "abcabc", true, "groups"},
		
		// Escape sequences
		{"digit_escape", "\\d", "5", true, "escapes"},
		{"digit_escape_fail", "\\d", "x", false, "escapes"},
		{"word_escape", "\\w", "a", true, "escapes"},
		{"space_escape", "\\s", " ", true, "escapes"},
	}
	
	// Simple category tracking
	basic_count := 0
	basic_passed := 0
	anchor_count := 0
	anchor_passed := 0
	class_count := 0
	class_passed := 0
	quant_count := 0
	quant_passed := 0
	alt_count := 0
	alt_passed := 0
	group_count := 0
	group_passed := 0
	escape_count := 0
	escape_passed := 0
	
	total_passed := 0
	total_tests := len(test_cases)
	
	for test in test_cases {
		fmt.printf("Testing %s: ", test.name)
		
		pattern, err := regexp.regexp(test.pattern)
		if err != .NoError {
			fmt.printf("FAIL (compile: %v)\n", err)
			continue
		}
		defer regexp.free_regexp(pattern)
		
		result, match_err := regexp.match(pattern, test.text)
		if match_err != .NoError {
			fmt.printf("FAIL (match: %v)\n", match_err)
			continue
		}
		
		if result.matched == test.expected {
			fmt.printf("PASS\n")
			total_passed += 1
			
			// Count by category
			switch test.category {
			case "basic":
				basic_passed += 1
			case "anchors":
				anchor_passed += 1
			case "classes":
				class_passed += 1
			case "quantifiers":
				quant_passed += 1
			case "alternation":
				alt_passed += 1
			case "groups":
				group_passed += 1
			case "escapes":
				escape_passed += 1
			}
		} else {
			fmt.printf("FAIL (expected %v, got %v)\n", test.expected, result.matched)
		}
		
		// Count total by category
		switch test.category {
		case "basic":
			basic_count += 1
		case "anchors":
			anchor_count += 1
		case "classes":
			class_count += 1
		case "quantifiers":
			quant_count += 1
		case "alternation":
			alt_count += 1
		case "groups":
			group_count += 1
		case "escapes":
			escape_count += 1
		}
	}
	
	// Print category results
	fmt.println()
	fmt.println("=== Category Results ===")
	if basic_count > 0 {
		fmt.printf("Basic Literals: %d/%d passed\n", basic_passed, basic_count)
	}
	if anchor_count > 0 {
		fmt.printf("Anchors: %d/%d passed\n", anchor_passed, anchor_count)
	}
	if class_count > 0 {
		fmt.printf("Character Classes: %d/%d passed\n", class_passed, class_count)
	}
	if quant_count > 0 {
		fmt.printf("Quantifiers: %d/%d passed\n", quant_passed, quant_count)
	}
	if alt_count > 0 {
		fmt.printf("Alternation: %d/%d passed\n", alt_passed, alt_count)
	}
	if group_count > 0 {
		fmt.printf("Groups: %d/%d passed\n", group_passed, group_count)
	}
	if escape_count > 0 {
		fmt.printf("Escape Sequences: %d/%d passed\n", escape_passed, escape_count)
	}
	
	fmt.println()
	fmt.printf("=== Overall Results ===\n")
	fmt.printf("Total: %d/%d tests passed (%.1f%%)\n", 
		total_passed, total_tests, f64(total_passed) / f64(total_tests) * 100.0)
}

// Run performance tests
run_performance_tests :: proc() {
	fmt.println()
	fmt.println("=== Performance Tests ===")
	fmt.println()
	
	// Test 1: Simple literal matching
	fmt.println("--- Literal Match Performance ---")
	pattern1, err1 := regexp.regexp("hello")
	if err1 == .NoError {
		defer regexp.free_regexp(pattern1)
		
		text1 := "The quick brown fox jumps over the lazy dog hello world"
		iterations1 := 1000
		
		start1 := time.now()
		for i := 0; i < iterations1; i += 1 {
			regexp.match(pattern1, text1)
		}
		end1 := time.now()
		
		duration1 := time.diff(end1, start1)
		fmt.printf("Pattern: 'hello'\n")
		fmt.printf("Text length: %d bytes\n", len(text1))
		fmt.printf("Iterations: %d\n", iterations1)
		fmt.printf("Total time: %v\n", duration1)
	}
	
	// Test 2: Complex pattern
	fmt.println()
	fmt.println("--- Complex Pattern Performance ---")
	pattern2, err2 := regexp.regexp("[a-z]+\\d+[a-z]+")
	if err2 == .NoError {
		defer regexp.free_regexp(pattern2)
		
		text2 := "abc123def456ghi789jkl"
		iterations2 := 500
		
		start2 := time.now()
		for i := 0; i < iterations2; i += 1 {
			regexp.match(pattern2, text2)
		}
		end2 := time.now()
		
		duration2 := time.diff(end2, start2)
		fmt.printf("Pattern: '[a-z]+\\\\d+[a-z]+'\n")
		fmt.printf("Text length: %d bytes\n", len(text2))
		fmt.printf("Iterations: %d\n", iterations2)
		fmt.printf("Total time: %v\n", duration2)
	}
}

main :: proc() {
	run_functionality_tests()
	run_performance_tests()
}