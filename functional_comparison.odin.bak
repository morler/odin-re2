package main

import "core:fmt"
import "core:os"
import "core:time"
import "core:strings"
import "regexp"

TestCase :: struct {
	name:        string,
	pattern:     string,
	text:        string,
	should_match: bool,
	expected:    string,
	description: string,
}

TestResult :: struct {
	test_case:   TestCase,
	matched:     bool,
	actual:      string,
	passed:      bool,
	compile_ns:  i64,
	match_ns:    i64,
	error:       string,
}

main :: proc() {
	test_cases := []TestCase{
		// Basic literals
		{"literal_simple", "hello", "hello world", true, "hello", "Simple literal matching"},
		{"literal_not_found", "xyz", "hello world", false, "", "Literal not in text"},
		{"literal_empty", "", "hello world", true, "", "Empty pattern matches"},
		{"literal_case_sensitive", "Hello", "hello world", false, "", "Case sensitive matching"},
		
		// Character classes
		{"char_class_simple", "[abc]", "banana", true, "b", "Simple character class"},
		{"char_class_range", "[a-z]", "Hello123", true, "e", "Character range"},
		{"char_class_negated", "[^0-9]", "123a456", true, "a", "Negated character class"},
		{"char_class_complex", "[A-Za-z0-9_]", "@#$%", false, "", "Complex character class no match"},
		
		// Quantifiers
		{"star_zero", "ab*c", "ac", true, "ac", "Star matches zero times"},
		{"star_multiple", "ab*c", "abbbbc", true, "abbbbc", "Star matches multiple times"},
		{"plus_one", "ab+c", "ac", false, "", "Plus requires at least one"},
		{"plus_multiple", "ab+c", "abbbc", true, "abbbc", "Plus matches multiple"},
		{"quest_present", "ab?c", "abc", true, "abc", "Question mark matches when present"},
		{"quest_absent", "ab?c", "ac", true, "ac", "Question mark matches when absent"},
		
		// Anchors
		{"begin_anchor", "^hello", "hello world", true, "hello", "Begin anchor match"},
		{"begin_anchor_fail", "^hello", "world hello", false, "", "Begin anchor no match"},
		{"end_anchor", "world$", "hello world", true, "world", "End anchor match"},
		{"end_anchor_fail", "world$", "world hello", false, "", "End anchor no match"},
		
		// Alternation
		{"alternate_first", "cat|dog", "cat", true, "cat", "Alternation first option"},
		{"alternate_second", "cat|dog", "dog", true, "dog", "Alternation second option"},
		{"alternate_none", "cat|dog", "bird", false, "", "Alternation no match"},
		
		// Groups and captures
		{"simple_group", "(ab)+", "abab", true, "abab", "Simple group with quantifier"},
		{"nested_group", "(a(b)c)+", "abcabc", true, "abc", "Nested group"},
		
		// Complex patterns
		{"email_pattern", "[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}", "test@example.com", true, "test@example.com", "Email pattern"},
		{"phone_pattern", "\\d{3}-\\d{3}-\\d{4}", "123-456-7890", true, "123-456-7890", "Phone number pattern"},
		
		// Unicode
		{"unicode_simple", "hÃ©llo", "hÃ©llo world", true, "hÃ©llo", "Simple Unicode"},
		{"emoji", "ðŸ˜Š", "Hello ðŸ˜Š world", true, "ðŸ˜Š", "Emoji matching"},
		
		// Edge cases
		{"special_chars", ".*+?^${}()|[]\\", ".*+?^${}()|[]\\", true, ".*+?^${}()|[]\\", "Special regex characters"},
		{"dot_matches_all", ".", "a", true, "a", "Dot matches single character"},
		{"dot_no_match", ".", "", false, "", "Dot doesn't match empty string"},
	}

	fmt.println("=== Odin RE2 Functional Comparison ===")
	fmt.printf("Running %d test cases...\n\n", len(test_cases))

	total_tests := len(test_cases)
	passed_tests := 0
	total_compile_time := i64(0)
	total_match_time := i64(0)

	results: [dynamic]TestResult

	for test_case in test_cases {
		result := run_test_case(test_case)
		append(&results, result)

		total_compile_time += result.compile_ns
		total_match_time += result.match_ns

		if result.passed {
			passed_tests += 1
		}

		status := "PASS"
		if !result.passed {
			status = "FAIL"
		}

		fmt.printf("[%s] %-20s | Pattern: %-15s | Text: %-20s | Expected: %v | Got: %v",
			status,
			test_case.name,
			fmt.tprintf("%q", test_case.pattern),
			fmt.tprintf("%q", test_case.text),
			test_case.should_match,
			result.matched)

		if result.error != "" {
			fmt.printf(" | Error: %s", result.error)
		}

		fmt.println()
	}

	// Summary statistics
	fmt.println("\n=== Summary ===")
	fmt.printf("Total Tests: %d\n", total_tests)
	fmt.printf("Passed: %d (%.1f%%)\n", passed_tests, f64(passed_tests) / f64(total_tests) * 100.0)
	fmt.printf("Failed: %d (%.1f%%)\n", total_tests - passed_tests, f64(total_tests - passed_tests) / f64(total_tests) * 100.0)
	fmt.printf("Average Compile Time: %.2f Î¼s\n", f64(total_compile_time) / f64(total_tests) / 1000.0)
	fmt.printf("Average Match Time: %.2f Î¼s\n", f64(total_match_time) / f64(total_tests) / 1000.0)
	fmt.printf("Total Time: %.2f ms\n", f64(total_compile_time + total_match_time) / 1_000_000.0)

	// Categorize failures
	fmt.println("\n=== Failure Analysis ===")
	unicode_failures := 0
	quantifier_failures := 0
	anchor_failures := 0
	group_failures := 0
	other_failures := 0

	for result in results {
		if !result.passed {
			if strings.contains(result.test_case.pattern, "[") || strings.contains(result.test_case.pattern, "ðŸ˜Š") {
				unicode_failures += 1
			} else if strings.contains_any(result.test_case.pattern, "*+?{") {
				quantifier_failures += 1
			} else if strings.contains_any(result.test_case.pattern, "^$") {
				anchor_failures += 1
			} else if strings.contains(result.test_case.pattern, "(") {
				group_failures += 1
			} else {
				other_failures += 1
			}
		}
	}

	fmt.printf("Unicode-related failures: %d\n", unicode_failures)
	fmt.printf("Quantifier-related failures: %d\n", quantifier_failures)
	fmt.printf("Anchor-related failures: %d\n", anchor_failures)
	fmt.printf("Group-related failures: %d\n", group_failures)
	fmt.printf("Other failures: %d\n", other_failures)

	// Performance analysis
	fmt.println("\n=== Performance Analysis ===")
	compile_times := make([]i64, len(results))
	match_times := make([]i64, len(results))
	
	for i in 0..<len(results) {
		compile_times[i] = results[i].compile_ns
		match_times[i] = results[i].match_ns
	}

	sort_slice(compile_times[:])
	sort_slice(match_times[:])

	fmt.printf("Compile Time - Min: %.2f Î¼s, Median: %.2f Î¼s, Max: %.2f Î¼s\n",
		f64(compile_times[0]) / 1000.0,
		f64(compile_times[len(compile_times) / 2]) / 1000.0,
		f64(compile_times[len(compile_times) - 1]) / 1000.0)

	fmt.printf("Match Time - Min: %.2f Î¼s, Median: %.2f Î¼s, Max: %.2f Î¼s\n",
		f64(match_times[0]) / 1000.0,
		f64(match_times[len(match_times) / 2]) / 1000.0,
		f64(match_times[len(match_times) - 1]) / 1000.0)
}

run_test_case :: proc(test_case: TestCase) -> TestResult {
	result := TestResult{
		test_case = test_case,
		matched = false,
		actual = "",
		passed = false,
		compile_ns = 0,
		match_ns = 0,
		error = "",
	}

	// Time compilation
	start_compile := time.now()
	pattern, compile_err := regexp.regexp(test_case.pattern)
	end_compile := time.now()
	compile_duration := time.diff(end_compile, start_compile)
	result.compile_ns = time.duration_nanoseconds(compile_duration)
	if result.compile_ns < 0 {
		result.compile_ns = -result.compile_ns
	}

	if compile_err != .NoError {
		result.error = fmt.tprintf("compile_error: %v", compile_err)
		return result
	}

	defer regexp.free_regexp(pattern)

	// Time matching
	start_match := time.now()
	match_result, match_err := regexp.match(pattern, test_case.text)
	end_match := time.now()
	match_duration := time.diff(end_match, start_match)
	result.match_ns = time.duration_nanoseconds(match_duration)
	if result.match_ns < 0 {
		result.match_ns = -result.match_ns
	}

	if match_err != .NoError {
		result.error = fmt.tprintf("match_error: %v", match_err)
		return result
	}

	result.matched = match_result.matched
	if match_result.matched {
		result.actual = test_case.text[match_result.full_match.start:match_result.full_match.end]
	}

	// Check if test passed
	result.passed = (result.matched == test_case.should_match)
	if result.matched && test_case.should_match && test_case.expected != "" {
		result.passed = result.passed && (result.actual == test_case.expected)
	}

	return result
}

sort_slice :: proc(slice: []i64) {
	for i := 1; i < len(slice); i += 1 {
		key := slice[i]
		j := i - 1
		for j >= 0 && slice[j] > key {
			slice[j + 1] = slice[j]
			j -= 1
		}
		slice[j + 1] = key
	}
}
